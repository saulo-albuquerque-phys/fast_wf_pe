# -*- coding: utf-8 -*-
"""jax_mlgw_import_from_data_fd_fft_save.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K3mPw0R14KmVoHZUDES-q_B9OwlHt-wk

# MLGW JAX DEFINITION

## IMPORTING LIBRARIES
"""

"""
Module NN_model.py
==================

Loads the same Neural Network model to generate the reduced PCA coeffiecients of a WF (this time in jax). This is only related to the final saved model from the vanilla model. If you have trained a new model, consider disregarding this file completely
"""
import sys
import os
import numpy as np
import json
import matplotlib.pyplot as plt
from shutil import copy2
import glob

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import jax
import jax.numpy as jnp
import jax.nn as jnn
from jax import random
from pathlib import Path
from itertools import combinations_with_replacement

"""## DEFINING THE IMPORTING FUNCTIONS"""

class loading_NN_weights_bias:
  def __init__(self,folder="./",model='0',mode="22", n_amp_layers=2, n_ph_01_layers=3, n_res_ph_01_layers=6, n_ph_2345_layers=2):
    self.importing_folder=folder+"model_"+model+"/"+mode+"/"
    self.numpy_data_folder=self.importing_folder+"new_data/"
    #loading hidden file
    self.residual_coefficients_01=np.loadtxt(self.numpy_data_folder+f"ph_residual_coefficients_01.dat")
    # Initialize w and b as empty lists
    self.w_amp_0 = []
    self.b_amp_0 = []
    for j in range(n_amp_layers):  # or range(number_of_layers) if you have more layers
        self.w_amp_0.append(np.loadtxt(self.numpy_data_folder+f"amp_model_weights_layer_{j}.dat"))
        self.b_amp_0.append(np.loadtxt(self.numpy_data_folder+f"amp_model_bias_layer_{j}.dat"))
    # saving them
    self.w_amp=self.w_amp_0
    self.b_amp=self.b_amp_0
    # Initialize w and b as empty lists
    self.w_ph_01_0 = []
    self.b_ph_01_0 = []
    for j in range(n_ph_01_layers):  # or range(number_of_layers) if you have more layers
        self.w_ph_01_0.append(np.loadtxt(self.numpy_data_folder+f"ph_model_01_weights_layer_{j}.dat"))
        self.b_ph_01_0.append(np.loadtxt(self.numpy_data_folder+f"ph_model_01_bias_layer_{j}.dat"))
    # saving them
    self.w_ph_01=self.w_ph_01_0
    self.b_ph_01=self.b_ph_01_0
    # Initialize w and b as empty lists
    self.w_res_ph_01_0 = []
    self.b_res_ph_01_0 = []
    for j in range(n_res_ph_01_layers):  # or range(number_of_layers) if you have more layers
        self.w_res_ph_01_0.append(np.loadtxt(self.numpy_data_folder+f"ph_res_model_01_weights_layer_{j}.dat"))
        self.b_res_ph_01_0.append(np.loadtxt(self.numpy_data_folder+f"ph_res_model_01_bias_layer_{j}.dat"))
    # saving them
    self.w_res_ph_01=self.w_res_ph_01_0
    self.b_res_ph_01=self.b_res_ph_01_0
    # Initialize w and b as empty lists
    self.w_ph_2345_0 = []
    self.b_ph_2345_0 = []
    for j in range(n_ph_2345_layers):  # or range(number_of_layers) if you have more layers
        self.w_ph_2345_0.append(np.loadtxt(self.numpy_data_folder+f"ph_model_2345_weights_layer_{j}.dat"))
        self.b_ph_2345_0.append(np.loadtxt(self.numpy_data_folder+f"ph_model_2345_bias_layer_{j}.dat"))
    # saving them
    self.w_ph_2345=self.w_ph_2345_0
    self.b_ph_2345=self.b_ph_2345_0

"""## DEFINING THE FUNCTIONS"""

class PCA_model:
	"""
PCA_model
=========
	Class aimed to deal with a PCA model.
	It fits a PCA model and is able to reduce a dataset (dimension D) to a lower dimensional (dimension K) one and to reconstruct low dimensional data to high dimensional one.
	It stores the following parameters (get them with get_PCA_params()):
		V (D,K)			matrix for dimensional reduction
		mu (D,)			the average value for each feature of dataset
		max_PC (K,)		maximum value of PC projection used to redurn scaled low dimensional data (activate it with scale_PC=True in fit_model methods())
		E (K,)			Eigenvalues of the PCs
	"""
	def __init__(self, filename = None):
		"""
	__init__
	========
		Constructor for PCA model. If filename is given, loads the model from file.
		Input:
			filename	file to load the model from
		"""
		self.PCA_params = []
		if filename is not None:
			self.load_model(filename)
		return None

	def load_model(self, filename):
		"""
	load_model
	==========
		Load the PCA parameters from file. The format is the same as save_model
		Input:
			filename	file to load the model from
		Output:
		"""
		data = np.loadtxt(filename) #loading data

		if not np.any(np.isnan(data)): #if there is no NaN, the old format is employed. This is to ensure code portability :(
			warnings.warn("Old PCA model type given. The model is loaded correctly but it is better to save the model to the new format.")
			V = data[:,:data.shape[1]-2] #(D,K)
			mu = data[:,data.shape[1]-2] #(D,)
			max_PC = data[:V.shape[1],data.shape[1]-1] #(K,)
			E = np.ones((V.shape[1],)) #(K,)
		else:
			V = data[:data.shape[0]-2,:data.shape[1]-1]
			mu = data[:data.shape[0]-2,data.shape[1]-1]
			max_PC = data[data.shape[0]-2,:data.shape[1]-1]
			E = data[data.shape[0]-1,:data.shape[1]-1]

		self.PCA_params= [V,mu,max_PC, E]
		return None

	def reconstruct_data(self, red_data, K = None):
		"""
	reconstruct_data
	================
		Gives the best estimate of high dimensional data given the low dimensional PCA approximation.
		Data are rescaled back to the original training measure inverting the preprocessing procedure.
		Input:
			red_data (N,K')	low dimensional representation of data
			K				Number of compontents to be used for reconstruction. If None, all the given components will be used
		Output:
			data (N,D)		high dimensional reconstruction of data (after inversion of preprocessing)
		"""
		if K is None: #adding zeros if the compontents are not to be used
			K = self.PCA_params[0].shape[1]

		if K < self.PCA_params[0].shape[1]:
			red_data = np.concatenate([red_data[:,:K], np.zeros((red_data.shape[0], self.PCA_params[0].shape[1]-K))], axis = 1)
		if red_data.shape[1]<self.PCA_params[0].shape[1]:
			red_data = np.concatenate([red_data[:,:K], np.zeros((red_data.shape[0], self.PCA_params[0].shape[1]-red_data.shape[1]))], axis = 1)

		red_data = np.multiply(red_data, self.PCA_params[2])
		data = np.matmul(red_data, self.PCA_params[0].T)
		data = data+self.PCA_params[1]
		return data.real

	def reconstruct_data_jnp(self, red_data, K = None):
		if K is None: #adding zeros if the compontents are not to be used
			K = self.PCA_params[0].shape[1]
		if K < self.PCA_params[0].shape[1]:
			red_data = jnp.concatenate([red_data[:,:K], jnp.zeros((red_data.shape[0], self.PCA_params[0].shape[1]-K))], axis = 1)
		if red_data.shape[1]<self.PCA_params[0].shape[1]:
			red_data = jnp.concatenate([red_data[:,:K], jnp.zeros((red_data.shape[0], self.PCA_params[0].shape[1]-red_data.shape[1]))], axis = 1)
		max_PC = jnp.array(self.PCA_params[2], dtype=jnp.float32)  # Convert to JAX array
		v = jnp.array(self.PCA_params[0], dtype=jnp.float32)  # Convert to JAX array
		mu = jnp.array(self.PCA_params[1], dtype=jnp.float32)  # Convert to JAX array
		red_data = jnp.multiply(red_data, max_PC)
		data = jnp.matmul(red_data, v.T)  # Matrix multiplication, transpose v to match the shape
		data = data + mu  # Adding mean
		return jnp.real(data)

def augment_features_amp(theta):
	"""
	Given a list of features string, it computes all the polynomial features.
	The feature string is of the format:

		2-eta_chieff_s1

	This represents a second order polynomial in the variables eta, chieff and s1

	"""
	#theta = np.atleast_2d(theta)
	feats_to_add = []
	features='1-mc_chieff'

	if not isinstance(features, list): features = [features]

	for feat_str in features:

		if not feat_str: continue

		if isinstance(feat_str, str):
			order, features_ = feat_str.split('-')
			order = int(order)
			features_ = features_.split('_')
		else:
			raise ValueError("Each input feature must be a string")

		if not (features_ and order>1): continue

		features_.sort()
		feat_list = []
		for i in range(1,order):
			feat_list.extend(combinations_with_replacement(features_, i+1))

		feat_vals = {}
		for f in features_:
			if f == 'eta':
				val = theta[:,0] / (1+theta[:,0])**2
			elif f == 'chieff':
				#chieff = (m1*s1+m2*s2)/(m1+m2) = (q*s1+s2)/(1+q)
				val = (theta[:,0]*theta[:,1] + theta[:,2]) / (1 + theta[:,0])
			elif f == 'q':
				val = theta[:,0]
			elif f == 'logq':
				val = jnp.log(theta[:,0])
			elif f == 's1':
				val = theta[:,1]
			elif f == 's2':
				val = theta[:,2]
			elif f == 'mc':
				val = jnp.power(theta[:,0] / (1+theta[:,0])**2, 3/5)
			else:
				raise ValueError("Feature '{}' not recognized: please consider submitting a patch to add support for your favoutite feature.".format(f))
			if f not in ['q', 's1', 's2']: feats_to_add.append(val[:,None])
			feat_vals[f] = val

		for feats in feat_list:
			val = 1
			for f in feats:
				val *= feat_vals[f]
			feats_to_add.append(val[:,None])

	return jnp.concatenate([theta, *feats_to_add], axis = 1)

def augment_features_ph_01(theta):
	"""
	Given a list of features string, it computes all the polynomial features.
	The feature string is of the format:

		2-eta_chieff_s1

	This represents a second order polynomial in the variables eta, chieff and s1

	"""
	#theta = np.atleast_2d(theta)
	feats_to_add = []
	features='3-mc_eta_logq_chieff'

	if not isinstance(features, list): features = [features]

	for feat_str in features:

		if not feat_str: continue

		if isinstance(feat_str, str):
			order, features_ = feat_str.split('-')
			order = int(order)
			features_ = features_.split('_')
		else:
			raise ValueError("Each input feature must be a string")

		if not (features_ and order>1): continue

		features_.sort()
		feat_list = []
		for i in range(1,order):
			feat_list.extend(combinations_with_replacement(features_, i+1))

		feat_vals = {}
		for f in features_:
			if f == 'eta':
				val = theta[:,0] / (1+theta[:,0])**2
			elif f == 'chieff':
				#chieff = (m1*s1+m2*s2)/(m1+m2) = (q*s1+s2)/(1+q)
				val = (theta[:,0]*theta[:,1] + theta[:,2]) / (1 + theta[:,0])
			elif f == 'q':
				val = theta[:,0]
			elif f == 'logq':
				val = jnp.log(theta[:,0])
			elif f == 's1':
				val = theta[:,1]
			elif f == 's2':
				val = theta[:,2]
			elif f == 'mc':
				val = jnp.power(theta[:,0] / (1+theta[:,0])**2, 3/5)
			else:
				raise ValueError("Feature '{}' not recognized: please consider submitting a patch to add support for your favoutite feature.".format(f))
			if f not in ['q', 's1', 's2']: feats_to_add.append(val[:,None])
			feat_vals[f] = val

		for feats in feat_list:
			val = 1
			for f in feats:
				val *= feat_vals[f]
			feats_to_add.append(val[:,None])

	return jnp.concatenate([theta, *feats_to_add], axis = 1)

def augment_features_ph_res_01(theta):
	"""
	Given a list of features string, it computes all the polynomial features.
	The feature string is of the format:

		2-eta_chieff_s1

	This represents a second order polynomial in the variables eta, chieff and s1

	"""
	#theta = np.atleast_2d(theta)
	feats_to_add = []
	features='2-mc_eta_logq_chieff'

	if not isinstance(features, list): features = [features]

	for feat_str in features:

		if not feat_str: continue

		if isinstance(feat_str, str):
			order, features_ = feat_str.split('-')
			order = int(order)
			features_ = features_.split('_')
		else:
			raise ValueError("Each input feature must be a string")

		if not (features_ and order>1): continue

		features_.sort()
		feat_list = []
		for i in range(1,order):
			feat_list.extend(combinations_with_replacement(features_, i+1))

		feat_vals = {}
		for f in features_:
			if f == 'eta':
				val = theta[:,0] / (1+theta[:,0])**2
			elif f == 'chieff':
				#chieff = (m1*s1+m2*s2)/(m1+m2) = (q*s1+s2)/(1+q)
				val = (theta[:,0]*theta[:,1] + theta[:,2]) / (1 + theta[:,0])
			elif f == 'q':
				val = theta[:,0]
			elif f == 'logq':
				val = jnp.log(theta[:,0])
			elif f == 's1':
				val = theta[:,1]
			elif f == 's2':
				val = theta[:,2]
			elif f == 'mc':
				val = jnp.power(theta[:,0] / (1+theta[:,0])**2, 3/5)
			else:
				raise ValueError("Feature '{}' not recognized: please consider submitting a patch to add support for your favoutite feature.".format(f))
			if f not in ['q', 's1', 's2']: feats_to_add.append(val[:,None])
			feat_vals[f] = val

		for feats in feat_list:
			val = 1
			for f in feats:
				val *= feat_vals[f]
			feats_to_add.append(val[:,None])

	return jnp.concatenate([theta, *feats_to_add], axis = 1)

def augment_features_ph_2345(theta):
	"""
	Given a list of features string, it computes all the polynomial features.
	The feature string is of the format:

		2-eta_chieff_s1

	This represents a second order polynomial in the variables eta, chieff and s1

	"""
	#theta = np.atleast_2d(theta)
	feats_to_add = []
	features='1-mc_eta_logq_chieff'

	if not isinstance(features, list): features = [features]

	for feat_str in features:

		if not feat_str: continue

		if isinstance(feat_str, str):
			order, features_ = feat_str.split('-')
			order = int(order)
			features_ = features_.split('_')
		else:
			raise ValueError("Each input feature must be a string")

		if not (features_ and order>1): continue

		features_.sort()
		feat_list = []
		for i in range(1,order):
			feat_list.extend(combinations_with_replacement(features_, i+1))

		feat_vals = {}
		for f in features_:
			if f == 'eta':
				val = theta[:,0] / (1+theta[:,0])**2
			elif f == 'chieff':
				#chieff = (m1*s1+m2*s2)/(m1+m2) = (q*s1+s2)/(1+q)
				val = (theta[:,0]*theta[:,1] + theta[:,2]) / (1 + theta[:,0])
			elif f == 'q':
				val = theta[:,0]
			elif f == 'logq':
				val = jnp.log(theta[:,0])
			elif f == 's1':
				val = theta[:,1]
			elif f == 's2':
				val = theta[:,2]
			elif f == 'mc':
				val = jnp.power(theta[:,0] / (1+theta[:,0])**2, 3/5)
			else:
				raise ValueError("Feature '{}' not recognized: please consider submitting a patch to add support for your favoutite feature.".format(f))
			if f not in ['q', 's1', 's2']: feats_to_add.append(val[:,None])
			feat_vals[f] = val

		for feats in feat_list:
			val = 1
			for f in feats:
				val *= feat_vals[f]
			feats_to_add.append(val[:,None])

	return jnp.concatenate([theta, *feats_to_add], axis = 1)

def intermediate_layer_fn(x, w, b):
        z = jnp.dot(x, w) + b
        a_out = jnn.sigmoid(z)
        return a_out

def final_layer_fn(x,w,b):
      z= jnp.dot(x, w) + b
      return z

def ampNN_function(theta,w,b):
  theta_amp=augment_features_amp(theta)
  a1=intermediate_layer_fn(theta_amp,w[0],b[0])
  a2=final_layer_fn(a1,w[1],b[1])
  return a2

def phi01_function(theta,w,b):
  theta_ph_01=augment_features_ph_01(theta)
  a1=intermediate_layer_fn(theta_ph_01,w[0],b[0])
  a2=intermediate_layer_fn(a1,w[1],b[1])
  a3=final_layer_fn(a2,w[2],b[2])
  return a3

def phi_res_01_function(theta,w,b):
  theta_res_ph_01=augment_features_ph_res_01(theta)
  a1=intermediate_layer_fn(theta_res_ph_01,w[0],b[0])
  a2=intermediate_layer_fn(a1,w[1],b[1])
  a3=intermediate_layer_fn(a2,w[2],b[2])
  a4=intermediate_layer_fn(a3,w[3],b[3])
  a5=intermediate_layer_fn(a4,w[4],b[4])
  a6=final_layer_fn(a5,w[5],b[5])
  return a6

def phi_res_01_function_final(theta,w,b,residual_coefficients_01):
  res1=phi_res_01_function(theta,w,b)
  res2=res1*residual_coefficients_01
  return res2

def phi_2345_function(theta,w,b):
  theta_ph_2345=augment_features_ph_2345(theta) # Changed from augment_features_ph_res_01
  a1=intermediate_layer_fn(theta_ph_2345,w[0],b[0])
  a2=final_layer_fn(a1,w[1],b[1])
  return a2

def model_output_amp(theta,w,b):
      return ampNN_function(theta,w,b)

def model_output_ph(theta,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01):
      coef_pre_01=phi01_function(theta,w01,b01)
      coef_res_01=phi_res_01_function_final(theta,wres01,bres01,residual_coefficients_01)
      coef_post_01=coef_pre_01+coef_res_01
      coef_ph_2345=phi_2345_function(theta,w2345,b2345)
      ph_coef=jnp.concatenate((coef_post_01,coef_ph_2345),axis=1)
      return ph_coef

def model_output_ph_2(theta,w01,b01,w2345,b2345):
      coef_pre_01=phi01_function(theta,w01,b01)
      coef_post_01=coef_pre_01
      coef_ph_2345=phi_2345_function(theta,w2345,b2345)
      ph_coef=jnp.concatenate((coef_post_01,coef_ph_2345),axis=1)
      return ph_coef

def get_raw_mode(theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01):
		"""
		This function takes as input theta=[q,spin1z,spin2z].
		With the theta=[q,spin1z,spin2z] it augment the features to the 37 necessary inputs, and only a portion of those inputs shall be used by the model_out_amp and model_output_ph
		"""
		rec_PCA_amp = model_output_amp(theta,wa,ba) #(N,K)
		rec_PCA_ph = model_output_ph(theta,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01) #(N,K)
		rec_amp = amp_PCA.reconstruct_data_jnp(rec_PCA_amp) #(N,D)
		rec_ph = ph_PCA.reconstruct_data_jnp(rec_PCA_ph) #(N,D)
		return rec_amp, rec_ph

def get_raw_mode_2(theta,wa,ba,w01,b01,w2345,b2345):
		"""
		This function takes as input theta=[q,spin1z,spin2z].
		With the theta=[q,spin1z,spin2z] it augment the features to the 37 necessary inputs, and only a portion of those inputs shall be used by the model_out_amp and model_output_ph
		"""
		rec_PCA_amp = model_output_amp(theta,wa,ba) #(N,K)
		rec_PCA_ph = model_output_ph_2(theta,w01,b01,w2345,b2345) #(N,K)
		rec_amp = amp_PCA.reconstruct_data_jnp(rec_PCA_amp) #(N,D)
		rec_ph = ph_PCA.reconstruct_data_jnp(rec_PCA_ph) #(N,D)
		return rec_amp, rec_ph

def __get_mode(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2)):
      """
      It generates the mode (2,2) by means of the function __get_mode,
      the input should be the 4D theta array defined as
      theta=[theta_1, theta_2, theta_3, theta_4]=[m1,m2,spin1z,spin2z]
      This theta is processed in the following way:
      The two masses [m1, m2]= [theta_1, theta_2] will be summed up to produce m_tot_us = m1+m2
      the mass-ratio q is extracted by taking the ration between m1 and m2.
      The final used theta input array is the array [theta_input_1, theta_input_2, theta_input_3]= [q, spin1z,spin2z] which is handed over to the function get_raw_mode, which demands a theta_final=[q,spin1z,spin2z] as input.

      THe output are the pure components h_c and h_p of the (2,2) mode, namely in terms of the amplitude and the phase amp and ph
      """
      q = jnp.divide(theta[:,0],theta[:,1]) #theta[:,0]/theta[:,1] #mass ratio (general) (N,)
      m_tot_us = theta[:,0] + theta[:,1]      #total mass in solar masses for the user
      theta_std = jnp.column_stack((q,theta[:,2],theta[:,3])) #(N,3)

      # Use masking and select to handle conditional swapping
      mask = theta_std[:,0] < 1.0
        # Create swapped versions of the relevant columns
      swapped_q = jnp.power(theta_std[:, 0], -1)
      swapped_theta2 = theta_std[:, 2]
      swapped_theta3 = theta_std[:, 1]

        # Select between original and swapped values based on the mask
      theta_std_swapped = jnp.column_stack([
          jax.lax.select(mask, swapped_q, theta_std[:, 0]),
          jax.lax.select(mask, swapped_theta2, theta_std[:, 1]),
          jax.lax.select(mask, swapped_theta3, theta_std[:, 2])
      ])

      # Ensure theta_final has the correct dimensions for get_raw_mode
      # Based on previous error, theta_final should be (N, 3) to match the expected input of model_output_ph
      # However, augment_features_jnp takes (N, 3) and returns (N, 37), which seems to be the intended input
      theta_final = theta_std_swapped
      # Use jax.vmap for vectorized interpolation

      def interp_fn(amp_i, ph_i, m_tot_us_i):
          interp_grid = jnp.divide(t_grid, m_tot_us_i)
          new_amp_i = jnp.interp(interp_grid, times_saved, amp_i, left=0, right=0)
          new_ph_i = jnp.interp(interp_grid, times_saved, ph_i)
          return new_amp_i, new_ph_i


      amp, ph =  get_raw_mode(theta_final,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01) #raw WF (N, N_grid)

      new_amp, new_ph = jax.vmap(interp_fn)(amp, ph, m_tot_us)

      # Recalculate nu based on the potentially swapped theta_std_swapped
      nu = theta_std_swapped[:,0]/(1 + theta_std_swapped[:,0])**2
      phi_diff = {(2,2):0, (2,1):jnp.pi/2, (3,3): -jnp.pi/2, (4,4):jnp.pi, (5,5): jnp.pi/2}
      # Ensure nu is broadcastable for multiplication
      amp = new_amp * nu[:, jnp.newaxis]
      phase = (new_ph.T - new_ph[:,0] + phi_diff[mode]).T #phase is zero at the beginning of the WF
      return amp, phase

def __get_mode_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2)):
      """
      It generates the mode (2,2) by means of the function __get_mode,
      the input should be the 4D theta array defined as
      theta=[theta_1, theta_2, theta_3, theta_4]=[m1,m2,spin1z,spin2z]
      This theta is processed in the following way:
      The two masses [m1, m2]= [theta_1, theta_2] will be summed up to produce m_tot_us = m1+m2
      the mass-ratio q is extracted by taking the ration between m1 and m2.
      The final used theta input array is the array [theta_input_1, theta_input_2, theta_input_3]= [q, spin1z,spin2z] which is handed over to the function get_raw_mode, which demands a theta_final=[q,spin1z,spin2z] as input.

      THe output are the pure components h_c and h_p of the (2,2) mode, namely in terms of the amplitude and the phase amp and ph
      """
      q = jnp.divide(theta[:,0],theta[:,1]) #theta[:,0]/theta[:,1] #mass ratio (general) (N,)
      m_tot_us = theta[:,0] + theta[:,1]      #total mass in solar masses for the user
      theta_std = jnp.column_stack((q,theta[:,2],theta[:,3])) #(N,3)

      # Use masking and select to handle conditional swapping
      mask = theta_std[:,0] < 1.0
        # Create swapped versions of the relevant columns
      swapped_q = jnp.power(theta_std[:, 0], -1)
      swapped_theta2 = theta_std[:, 2]
      swapped_theta3 = theta_std[:, 1]

        # Select between original and swapped values based on the mask
      theta_std_swapped = jnp.column_stack([
          jax.lax.select(mask, swapped_q, theta_std[:, 0]),
          jax.lax.select(mask, swapped_theta2, theta_std[:, 1]),
          jax.lax.select(mask, swapped_theta3, theta_std[:, 2])
      ])

      # Ensure theta_final has the correct dimensions for get_raw_mode
      # Based on previous error, theta_final should be (N, 3) to match the expected input of model_output_ph
      # However, augment_features_jnp takes (N, 3) and returns (N, 37), which seems to be the intended input
      theta_final = theta_std_swapped
      # Use jax.vmap for vectorized interpolation

      def interp_fn(amp_i, ph_i, m_tot_us_i):
          interp_grid = jnp.divide(t_grid, m_tot_us_i)
          new_amp_i = jnp.interp(interp_grid, times_saved, amp_i, left=0, right=0)
          new_ph_i = jnp.interp(interp_grid, times_saved, ph_i)
          return new_amp_i, new_ph_i


      amp, ph =  get_raw_mode_2(theta_final,wa,ba,w01,b01,w2345,b2345) #raw WF (N, N_grid)

      new_amp, new_ph = jax.vmap(interp_fn)(amp, ph, m_tot_us)

      # Recalculate nu based on the potentially swapped theta_std_swapped
      nu = theta_std_swapped[:,0]/(1 + theta_std_swapped[:,0])**2
      phi_diff = {(2,2):0, (2,1):jnp.pi/2, (3,3): -jnp.pi/2, (4,4):jnp.pi, (5,5): jnp.pi/2}
      # Ensure nu is broadcastable for multiplication
      amp = new_amp * nu[:, jnp.newaxis]
      phase = (new_ph.T - new_ph[:,0] + phi_diff[mode]).T #phase is zero at the beginning of the WF
      return amp, phase

def get_mode(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2)):
		"""
		It generates the mode (2,2) by means of the function __get_mode,
		the input should be the 4D theta array defined as
		theta=[theta_1, theta_2, theta_3, theta_4]=[m1,m2,spin1z,spin2z]
		THe output are the pure components h_c and h_p of the (2,2) mode, namely in terms of the amplitude and the phase amp and phase
		"""
		amp,phase = __get_mode(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2))
		return amp, phase #(N,D)

def get_mode_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2)):
		"""
		It generates the mode (2,2) by means of the function __get_mode,
		the input should be the 4D theta array defined as
		theta=[theta_1, theta_2, theta_3, theta_4]=[m1,m2,spin1z,spin2z]
		THe output are the pure components h_c and h_p of the (2,2) mode, namely in terms of the amplitude and the phase amp and phase
		"""
		amp,phase = __get_mode_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2))
		return amp, phase #(N,D)

def __get_WF_jnp(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2)):
                """
                Generates the waves in time domain, building it as a sum of modes weighted by spherical harmonics. Called by get_WF.
                Accepts only input features as [q,s1,s2] or [m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0].

                Input:
                        theta: :class:`~numpy:numpy.ndarray`
                                shape (D,)/(N,D) - source parameters to make prediction at (D=7)
                        t_grid: :class:`~numpy:numpy.ndarray`
                                shape (D',) - a grid in (reduced) time to evaluate the wave at (uses np.interp)
                        modes: list
                                list of modes employed for building the WF (if None, every mode available is employed)

                         Here you should give a 7 dimmensional theta where
                            theta= [m1,m2, spin1_z, spin2_z, D_l, inclination, phi_0]

                          This 7 dimmensional input for theta will be processed in the following way.
                          The two masses [m1, m2]= [theta_1, theta_2] will be summed up to produce m_tot_us = m1+m2
                          and the distance dist=theta_4 will be used to produce the value for the distance "dist".
                          Those values will give us the amplitude pre factor "amp_prefactor".
                          Finally, only the first four components of theta = [theta_1, theta_2, theta_3, theta_4] = [m1,m2,spin1z,spin2z] will be used to produce the mode for amp_22, ph_22 by means
                          of the previously defined function get_mode
                Ouput:
                        h_plus, h_cross: :class:`~numpy:numpy.ndarray`
                                shape (D,)/(N,D) - desidered polarizations (if it applies)
                """
                #computing amplitude prefactor
                prefactor = 4.7864188273360336e-20 # G/c^2*(M_sun/Mpc)
                m_tot_us = theta[:,0] + theta[:,1]    #total mass in solar masses for the user  (N,)
                dist= theta[:,4]
                amp_prefactor = prefactor * m_tot_us / dist # G/c^2 (M / d_L)

                #theta input for the get_mode function
                theta_input=theta[:,:4]
                #generating waves and returning to user

                amp_22, ph_22 = get_mode(t_grid, theta_input,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2))
                # Correct broadcasting for amp_prefactor
                amp_22 = jnp.sqrt(5/(4.*jnp.pi)) * amp_22 * amp_prefactor[:, jnp.newaxis] #G/c^2*(M_sun/Mpc) nu *(M/M_sun)/(d_L/Mpc)
                #setting spherical harmonics by hand
                c_i = jnp.cos(theta[:,5]) #(N,)
                h_p = jnp.multiply(jnp.multiply(amp_22.T,jnp.cos(ph_22.T+2.*theta[:,6])), 0.5*(1+jnp.square(c_i)) ).T
                h_c = jnp.multiply(jnp.multiply(amp_22.T,jnp.sin(ph_22.T+2.*theta[:,6])), c_i ).T
                return h_p, h_c

def __get_WF_jnp_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2)):
                """
                Generates the waves in time domain, building it as a sum of modes weighted by spherical harmonics. Called by get_WF.
                Accepts only input features as [q,s1,s2] or [m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0].

                Input:
                        theta: :class:`~numpy:numpy.ndarray`
                                shape (D,)/(N,D) - source parameters to make prediction at (D=7)
                        t_grid: :class:`~numpy:numpy.ndarray`
                                shape (D',) - a grid in (reduced) time to evaluate the wave at (uses np.interp)
                        modes: list
                                list of modes employed for building the WF (if None, every mode available is employed)

                         Here you should give a 7 dimmensional theta where
                            theta= [m1,m2, spin1_z, spin2_z, D_l, inclination, phi_0]

                          This 7 dimmensional input for theta will be processed in the following way.
                          The two masses [m1, m2]= [theta_1, theta_2] will be summed up to produce m_tot_us = m1+m2
                          and the distance dist=theta_4 will be used to produce the value for the distance "dist".
                          Those values will give us the amplitude pre factor "amp_prefactor".
                          Finally, only the first four components of theta = [theta_1, theta_2, theta_3, theta_4] = [m1,m2,spin1z,spin2z] will be used to produce the mode for amp_22, ph_22 by means
                          of the previously defined function get_mode
                Ouput:
                        h_plus, h_cross: :class:`~numpy:numpy.ndarray`
                                shape (D,)/(N,D) - desidered polarizations (if it applies)
                """
                #computing amplitude prefactor
                prefactor = 4.7864188273360336e-20 # G/c^2*(M_sun/Mpc)
                m_tot_us = theta[:,0] + theta[:,1]    #total mass in solar masses for the user  (N,)
                dist= theta[:,4]
                amp_prefactor = prefactor * m_tot_us / dist # G/c^2 (M / d_L)

                #theta input for the get_mode function
                theta_input=theta[:,:4]
                #generating waves and returning to user

                amp_22, ph_22 = get_mode_2(t_grid, theta_input,wa,ba,w01,b01,w2345,b2345,mode=(2,2))
                # Correct broadcasting for amp_prefactor
                amp_22 = jnp.sqrt(5/(4.*jnp.pi)) * amp_22 * amp_prefactor[:, jnp.newaxis] #G/c^2*(M_sun/Mpc) nu *(M/M_sun)/(d_L/Mpc)
                #setting spherical harmonics by hand
                c_i = jnp.cos(theta[:,5]) #(N,)
                h_p = jnp.multiply(jnp.multiply(amp_22.T,jnp.cos(ph_22.T+2.*theta[:,6])), 0.5*(1+jnp.square(c_i)) ).T
                h_c = jnp.multiply(jnp.multiply(amp_22.T,jnp.sin(ph_22.T+2.*theta[:,6])), c_i ).T
                return h_p, h_c

def get_WF_jnp(t_grid, theta, wa, ba, w01, b01, wres01, bres01, w2345, b2345,residual_coefficients_01, mode=(2,2)):
		"""
		Generates a WF according to the model. It makes all the required preprocessing to include wave dependance on the full 14 parameters space of the GW forms. It outputs the plus cross polarization of the WF.
		The WF is shifted such that the peak of the 22 mode is placed at t=0. If the reference phase is 0, the phase of the 22 mode is 0 at the beginning of the time grid.
		It accepts data in the following layout of D features:

			D = 7	[m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0]

		In the D = 3 layout, the total mass is set to 20 M_sun by default.
		Warning: last layout (D=14) is made only for compatibility with lalsuite software. The implemented variables are those in D=7 layout; the other are dummy variables and will not be considered.
		Unit of measures:

			[mass] = M_sun

			[D_L] = Mpc

			[spin] = adimensional

		Input:
			theta: :class:`~numpy:numpy.ndarray`
				shape (D,)/(N,D) - source parameters to make prediction at
			t_grid: :class:`~numpy:numpy.ndarray`
				shape (D',) - a grid in (reduced) time to evaluate the wave at (uses np.interp)
			modes: list
				list of modes employed for building the WF (if None, every mode available is employed
      Here you should give a 7 dimmensional theta where
      theta= [m1,m2, spin1_z, spin2_z, D_l, inclination, phi_0]

		Ouput:
			h_plus, h_cross (D,)/(N,D)		desidered polarizations (if it applies)
		"""
		#TODO: this function eventually should take f_ref. If f_ref is not None, the spin will be evolved up to our merger frequency
		D= theta.shape[1] #number of features given
		indices = [i for i in range(D)]
		indices_new_theta = indices
		#generating waves and returning to user
		h_plus, h_cross = __get_WF_jnp(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2)) #(N,D)
		return h_plus, h_cross #(N,D)

def get_WF_jnp_2(t_grid, theta, wa, ba, w01, b01, w2345, b2345, mode=(2,2)):
		"""
		Generates a WF according to the model. It makes all the required preprocessing to include wave dependance on the full 14 parameters space of the GW forms. It outputs the plus cross polarization of the WF.
		The WF is shifted such that the peak of the 22 mode is placed at t=0. If the reference phase is 0, the phase of the 22 mode is 0 at the beginning of the time grid.
		It accepts data in the following layout of D features:

			D = 7	[m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0]

		In the D = 3 layout, the total mass is set to 20 M_sun by default.
		Warning: last layout (D=14) is made only for compatibility with lalsuite software. The implemented variables are those in D=7 layout; the other are dummy variables and will not be considered.
		Unit of measures:

			[mass] = M_sun

			[D_L] = Mpc

			[spin] = adimensional

		Input:
			theta: :class:`~numpy:numpy.ndarray`
				shape (D,)/(N,D) - source parameters to make prediction at
			t_grid: :class:`~numpy:numpy.ndarray`
				shape (D',) - a grid in (reduced) time to evaluate the wave at (uses np.interp)
			modes: list
				list of modes employed for building the WF (if None, every mode available is employed
      Here you should give a 7 dimmensional theta where
      theta= [m1,m2, spin1_z, spin2_z, D_l, inclination, phi_0]

		Ouput:
			h_plus, h_cross (D,)/(N,D)		desidered polarizations (if it applies)
		"""
		#TODO: this function eventually should take f_ref. If f_ref is not None, the spin will be evolved up to our merger frequency
		#generating waves and returning to user
		h_plus, h_cross = __get_WF_jnp_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2)) #(N,D)
		return h_plus, h_cross #(N,D)

"""## IMPORTING THE MODEL"""

loading_NN=loading_NN_weights_bias()

w_AMP=loading_NN.w_amp
b_AMP=loading_NN.b_amp

w_PH_01=loading_NN.w_ph_01
b_PH_01=loading_NN.b_ph_01

w_PH_res_01=loading_NN.w_res_ph_01
b_PH_res_01=loading_NN.b_res_ph_01

w_PH_2345=loading_NN.w_ph_2345
b_PH_2345=loading_NN.b_ph_2345

residual_coefficients_01=loading_NN.residual_coefficients_01

folder=loading_NN.importing_folder

folder_path = Path(folder)
amp_PCA = PCA_model()
amp_PCA.load_model(*glob.glob(str(folder_path/"amp_PCA_model*")))
ph_PCA = PCA_model()
ph_PCA.load_model(*glob.glob(str(folder_path/"ph_PCA_model*")))
times_saved = np.loadtxt(*glob.glob(str(folder_path/"times*")))

t_min_red=times_saved[0]
t_max_red=times_saved[-1]

"""# TD and FD WRAPPER FUNCTION

## DEFINING THE FUNCTION
"""

def GET_WF_TD(t_grid,theta):
  hp,hc=get_WF_jnp(t_grid, theta, w_AMP,b_AMP,w_PH_01,b_PH_01,w_PH_res_01,b_PH_res_01,w_PH_2345,b_PH_2345,residual_coefficients_01,mode=(2,2))
  return hp,hc

"""
#DEFINE A TIME GRID
"""

def define_time_grid(theta,sample_rate):
  m1=theta[:,0]
  m2=theta[:,1]
  m_tot=m1+m2
  m_tot_max=jnp.max(m_tot)
  t_min=t_min_red*m_tot_max
  t_max=t_max_red*m_tot_max
  time_interval=t_max-t_min
  delta_t=1/sample_rate
  time_grid=jnp.arange(t_min, t_max, delta_t)
  return time_grid


"""## DEFINING THE FOURIER TRANSFORM"""

def get_wf_cyclic_time_shifted_to_right(time_grid,theta):
  m1=theta[:,0]
  m2=theta[:,1]
  m_tot=m1+m2
  m_tot_max_index=jnp.argmax(m_tot)
  t_min=t_min_red*m_tot
  t_max=t_max_red*m_tot

  index_time_min=jnp.searchsorted(time_grid,t_min)
  index_time_max=jnp.searchsorted(time_grid,t_max)

  index_time_min_min=index_time_min[m_tot_max_index]
  index_time_max_max=index_time_max[m_tot_max_index]

  index_rolling=index_time_max_max-index_time_max

  hp,hc=GET_WF_TD(time_grid,theta)

  hp_cycled_rolled_to_left=jax.vmap(jnp.roll,in_axes=(0,0))(hp,-index_rolling)
  hc_cycled_rolled_to_left=jax.vmap(jnp.roll,in_axes=(0,0))(hc,-index_rolling)
  return hp_cycled_rolled_to_left,hc_cycled_rolled_to_left

def interpolation(f_new,f_old,hp):
  return jnp.interp(f_new,f_old,hp)

def GET_WF_FD(time_grid,theta):
  hp,hc=get_wf_cyclic_time_shifted_to_right(time_grid,theta)
  hp_fft=jnp.fft.rfft(hp)*(time_grid[1]-time_grid[0])
  hc_fft=jnp.fft.rfft(hc)*(time_grid[1]-time_grid[0])
  f_grid=jnp.fft.rfftfreq(len(time_grid),time_grid[1]-time_grid[0])
  return hp_fft,hc_fft,f_grid

def GET_WF_FD_interp(time_grid,frequency_grid,theta):
  hp,hc=get_wf_cyclic_time_shifted_to_right(time_grid,theta)
  hp_fft=jnp.fft.rfft(hp)*(time_grid[1]-time_grid[0])
  hc_fft=jnp.fft.rfft(hc)*(time_grid[1]-time_grid[0])
  f_grid=jnp.fft.rfftfreq(len(time_grid),time_grid[1]-time_grid[0])
  hp_fft_interp=jax.vmap(interpolation,in_axes=(None,None,0))(frequency_grid,f_grid,hp_fft)
  hc_fft_interp=jax.vmap(interpolation,in_axes=(None,None,0))(frequency_grid,f_grid,hc_fft)
  return hp_fft_interp, hc_fft_interp

def GET_WF_FD_interp_tm(frequency_grid,theta,sample_rate,m_tot):
  t_min=t_min_red*m_tot
  t_max=t_max_red*m_tot	
  delta_t=1/sample_rate	
  time_grid=jnp.arange(t_min,t_max,delta_t)	
  hp,hc=get_wf_cyclic_time_shifted_to_right(time_grid,theta)
  hp_fft=jnp.fft.rfft(hp)*(time_grid[1]-time_grid[0])
  hc_fft=jnp.fft.rfft(hc)*(time_grid[1]-time_grid[0])
  f_grid=jnp.fft.rfftfreq(len(time_grid),time_grid[1]-time_grid[0])
  hp_fft_interp=jax.vmap(interpolation,in_axes=(None,None,0))(frequency_grid,f_grid,hp_fft)
  hc_fft_interp=jax.vmap(interpolation,in_axes=(None,None,0))(frequency_grid,f_grid,hc_fft)
  return hp_fft_interp, hc_fft_interp

m_tot=80
sample_rate=4096
t_min=t_min_red*m_tot
t_max=t_max_red*m_tot	

delta_t_0=1/sample_rate
time_grid=jnp.arange(t_min,t_max,delta_t_0)

def GET_WF_FD_interp_test(frequency_grid,m1,m2,s1z,s2z,d=1,inclination=0,phi_0=0):
  theta=jnp.array([[m1,m2,s1z,s2z,d,inclination,phi_0]])
  hp,hc=get_wf_cyclic_time_shifted_to_right(time_grid,theta)
  hp_fft=jnp.fft.rfft(hp)*(time_grid[1]-time_grid[0])
  hc_fft=jnp.fft.rfft(hc)*(time_grid[1]-time_grid[0])
  f_grid=jnp.fft.rfftfreq(len(time_grid),time_grid[1]-time_grid[0])
  hp_fft_interp=jax.vmap(interpolation,in_axes=(None,None,0))(frequency_grid,f_grid,hp_fft)
  hc_fft_interp=jax.vmap(interpolation,in_axes=(None,None,0))(frequency_grid,f_grid,hc_fft)
  hp_f=hp_fft_interp[0]
  hc_f=hc_fft_interp[0]
  return hp_fft_interp, hc_fft_interp
