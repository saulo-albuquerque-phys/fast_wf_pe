# -*- coding: utf-8 -*-
"""jax_mlgw_import_from_data_fd_fft_save.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K3mPw0R14KmVoHZUDES-q_B9OwlHt-wk

# MLGW JAX DEFINITION

## IMPORTING LIBRARIES
"""

"""
Module NN_model.py
==================

Loads the same Neural Network model to generate the reduced PCA coeffiecients of a WF (this time in jax). This is only related to the final saved model from the vanilla model. If you have trained a new model, consider disregarding this file completely
"""
import sys
import os
import numpy as np
import json
import matplotlib.pyplot as plt
from shutil import copy2
import glob

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import jax
import jax.numpy as jnp
import jax.nn as jnn
from jax import random
from pathlib import Path
from itertools import combinations_with_replacement

"""## DEFINING THE IMPORTING FUNCTIONS"""

class loading_NN_weights_bias:
  def __init__(self,folder="./",model='0',mode="22", n_amp_layers=2, n_ph_01_layers=3, n_res_ph_01_layers=6, n_ph_2345_layers=2):
    self.importing_folder=folder+"model_"+model+"/"+mode+"/"
    self.numpy_data_folder=self.importing_folder+"new_data/"
    #loading hidden file
    self.residual_coefficients_01=np.loadtxt(self.numpy_data_folder+f"ph_residual_coefficients_01.dat")
    # Initialize w and b as empty lists
    self.w_amp_0 = []
    self.b_amp_0 = []
    for j in range(n_amp_layers):  # or range(number_of_layers) if you have more layers
        self.w_amp_0.append(np.loadtxt(self.numpy_data_folder+f"amp_model_weights_layer_{j}.dat"))
        self.b_amp_0.append(np.loadtxt(self.numpy_data_folder+f"amp_model_bias_layer_{j}.dat"))
    # saving them
    self.w_amp=self.w_amp_0
    self.b_amp=self.b_amp_0
    # Initialize w and b as empty lists
    self.w_ph_01_0 = []
    self.b_ph_01_0 = []
    for j in range(n_ph_01_layers):  # or range(number_of_layers) if you have more layers
        self.w_ph_01_0.append(np.loadtxt(self.numpy_data_folder+f"ph_model_01_weights_layer_{j}.dat"))
        self.b_ph_01_0.append(np.loadtxt(self.numpy_data_folder+f"ph_model_01_bias_layer_{j}.dat"))
    # saving them
    self.w_ph_01=self.w_ph_01_0
    self.b_ph_01=self.b_ph_01_0
    # Initialize w and b as empty lists
    self.w_res_ph_01_0 = []
    self.b_res_ph_01_0 = []
    for j in range(n_res_ph_01_layers):  # or range(number_of_layers) if you have more layers
        self.w_res_ph_01_0.append(np.loadtxt(self.numpy_data_folder+f"ph_res_model_01_weights_layer_{j}.dat"))
        self.b_res_ph_01_0.append(np.loadtxt(self.numpy_data_folder+f"ph_res_model_01_bias_layer_{j}.dat"))
    # saving them
    self.w_res_ph_01=self.w_res_ph_01_0
    self.b_res_ph_01=self.b_res_ph_01_0
    # Initialize w and b as empty lists
    self.w_ph_2345_0 = []
    self.b_ph_2345_0 = []
    for j in range(n_ph_2345_layers):  # or range(number_of_layers) if you have more layers
        self.w_ph_2345_0.append(np.loadtxt(self.numpy_data_folder+f"ph_model_2345_weights_layer_{j}.dat"))
        self.b_ph_2345_0.append(np.loadtxt(self.numpy_data_folder+f"ph_model_2345_bias_layer_{j}.dat"))
    # saving them
    self.w_ph_2345=self.w_ph_2345_0
    self.b_ph_2345=self.b_ph_2345_0

"""## DEFINING THE FUNCTIONS"""

class PCA_model:
	"""
PCA_model
=========
	Class aimed to deal with a PCA model.
	It fits a PCA model and is able to reduce a dataset (dimension D) to a lower dimensional (dimension K) one and to reconstruct low dimensional data to high dimensional one.
	It stores the following parameters (get them with get_PCA_params()):
		V (D,K)			matrix for dimensional reduction
		mu (D,)			the average value for each feature of dataset
		max_PC (K,)		maximum value of PC projection used to redurn scaled low dimensional data (activate it with scale_PC=True in fit_model methods())
		E (K,)			Eigenvalues of the PCs
	"""
	def __init__(self, filename = None):
		"""
	__init__
	========
		Constructor for PCA model. If filename is given, loads the model from file.
		Input:
			filename	file to load the model from
		"""
		self.PCA_params = []
		if filename is not None:
			self.load_model(filename)
		return None

	def load_model(self, filename):
		"""
	load_model
	==========
		Load the PCA parameters from file. The format is the same as save_model
		Input:
			filename	file to load the model from
		Output:
		"""
		data = np.loadtxt(filename) #loading data

		if not np.any(np.isnan(data)): #if there is no NaN, the old format is employed. This is to ensure code portability :(
			warnings.warn("Old PCA model type given. The model is loaded correctly but it is better to save the model to the new format.")
			V = data[:,:data.shape[1]-2] #(D,K)
			mu = data[:,data.shape[1]-2] #(D,)
			max_PC = data[:V.shape[1],data.shape[1]-1] #(K,)
			E = np.ones((V.shape[1],)) #(K,)
		else:
			V = data[:data.shape[0]-2,:data.shape[1]-1]
			mu = data[:data.shape[0]-2,data.shape[1]-1]
			max_PC = data[data.shape[0]-2,:data.shape[1]-1]
			E = data[data.shape[0]-1,:data.shape[1]-1]

		self.PCA_params= [V,mu,max_PC, E]
		return None

	def reconstruct_data(self, red_data, K = None):
		"""
	reconstruct_data
	================
		Gives the best estimate of high dimensional data given the low dimensional PCA approximation.
		Data are rescaled back to the original training measure inverting the preprocessing procedure.
		Input:
			red_data (N,K')	low dimensional representation of data
			K				Number of compontents to be used for reconstruction. If None, all the given components will be used
		Output:
			data (N,D)		high dimensional reconstruction of data (after inversion of preprocessing)
		"""
		if K is None: #adding zeros if the compontents are not to be used
			K = self.PCA_params[0].shape[1]

		if K < self.PCA_params[0].shape[1]:
			red_data = np.concatenate([red_data[:,:K], np.zeros((red_data.shape[0], self.PCA_params[0].shape[1]-K))], axis = 1)
		if red_data.shape[1]<self.PCA_params[0].shape[1]:
			red_data = np.concatenate([red_data[:,:K], np.zeros((red_data.shape[0], self.PCA_params[0].shape[1]-red_data.shape[1]))], axis = 1)

		red_data = np.multiply(red_data, self.PCA_params[2])
		data = np.matmul(red_data, self.PCA_params[0].T)
		data = data+self.PCA_params[1]
		return data.real

	def reconstruct_data_jnp(self, red_data, K = None):
		if K is None: #adding zeros if the compontents are not to be used
			K = self.PCA_params[0].shape[1]
		if K < self.PCA_params[0].shape[1]:
			red_data = jnp.concatenate([red_data[:,:K], jnp.zeros((red_data.shape[0], self.PCA_params[0].shape[1]-K))], axis = 1)
		if red_data.shape[1]<self.PCA_params[0].shape[1]:
			red_data = jnp.concatenate([red_data[:,:K], jnp.zeros((red_data.shape[0], self.PCA_params[0].shape[1]-red_data.shape[1]))], axis = 1)
		max_PC = jnp.array(self.PCA_params[2], dtype=jnp.float32)  # Convert to JAX array
		v = jnp.array(self.PCA_params[0], dtype=jnp.float32)  # Convert to JAX array
		mu = jnp.array(self.PCA_params[1], dtype=jnp.float32)  # Convert to JAX array
		red_data = jnp.multiply(red_data, max_PC)
		data = jnp.matmul(red_data, v.T)  # Matrix multiplication, transpose v to match the shape
		data = data + mu  # Adding mean
		return jnp.real(data)

def augment_features_amp(theta):
	"""
	Given a list of features string, it computes all the polynomial features.
	The feature string is of the format:

		2-eta_chieff_s1

	This represents a second order polynomial in the variables eta, chieff and s1

	"""
	#theta = np.atleast_2d(theta)
	feats_to_add = []
	features='1-mc_chieff'

	if not isinstance(features, list): features = [features]

	for feat_str in features:

		if not feat_str: continue

		if isinstance(feat_str, str):
			order, features_ = feat_str.split('-')
			order = int(order)
			features_ = features_.split('_')
		else:
			raise ValueError("Each input feature must be a string")

		if not (features_ and order>1): continue

		features_.sort()
		feat_list = []
		for i in range(1,order):
			feat_list.extend(combinations_with_replacement(features_, i+1))

		feat_vals = {}
		for f in features_:
			if f == 'eta':
				val = theta[:,0] / (1+theta[:,0])**2
			elif f == 'chieff':
				#chieff = (m1*s1+m2*s2)/(m1+m2) = (q*s1+s2)/(1+q)
				val = (theta[:,0]*theta[:,1] + theta[:,2]) / (1 + theta[:,0])
			elif f == 'q':
				val = theta[:,0]
			elif f == 'logq':
				val = jnp.log(theta[:,0])
			elif f == 's1':
				val = theta[:,1]
			elif f == 's2':
				val = theta[:,2]
			elif f == 'mc':
				val = jnp.power(theta[:,0] / (1+theta[:,0])**2, 3/5)
			else:
				raise ValueError("Feature '{}' not recognized: please consider submitting a patch to add support for your favoutite feature.".format(f))
			if f not in ['q', 's1', 's2']: feats_to_add.append(val[:,None])
			feat_vals[f] = val

		for feats in feat_list:
			val = 1
			for f in feats:
				val *= feat_vals[f]
			feats_to_add.append(val[:,None])

	return jnp.concatenate([theta, *feats_to_add], axis = 1)

def augment_features_ph_01(theta):
	"""
	Given a list of features string, it computes all the polynomial features.
	The feature string is of the format:

		2-eta_chieff_s1

	This represents a second order polynomial in the variables eta, chieff and s1

	"""
	#theta = np.atleast_2d(theta)
	feats_to_add = []
	features='3-mc_eta_logq_chieff'

	if not isinstance(features, list): features = [features]

	for feat_str in features:

		if not feat_str: continue

		if isinstance(feat_str, str):
			order, features_ = feat_str.split('-')
			order = int(order)
			features_ = features_.split('_')
		else:
			raise ValueError("Each input feature must be a string")

		if not (features_ and order>1): continue

		features_.sort()
		feat_list = []
		for i in range(1,order):
			feat_list.extend(combinations_with_replacement(features_, i+1))

		feat_vals = {}
		for f in features_:
			if f == 'eta':
				val = theta[:,0] / (1+theta[:,0])**2
			elif f == 'chieff':
				#chieff = (m1*s1+m2*s2)/(m1+m2) = (q*s1+s2)/(1+q)
				val = (theta[:,0]*theta[:,1] + theta[:,2]) / (1 + theta[:,0])
			elif f == 'q':
				val = theta[:,0]
			elif f == 'logq':
				val = jnp.log(theta[:,0])
			elif f == 's1':
				val = theta[:,1]
			elif f == 's2':
				val = theta[:,2]
			elif f == 'mc':
				val = jnp.power(theta[:,0] / (1+theta[:,0])**2, 3/5)
			else:
				raise ValueError("Feature '{}' not recognized: please consider submitting a patch to add support for your favoutite feature.".format(f))
			if f not in ['q', 's1', 's2']: feats_to_add.append(val[:,None])
			feat_vals[f] = val

		for feats in feat_list:
			val = 1
			for f in feats:
				val *= feat_vals[f]
			feats_to_add.append(val[:,None])

	return jnp.concatenate([theta, *feats_to_add], axis = 1)

def augment_features_ph_res_01(theta):
	"""
	Given a list of features string, it computes all the polynomial features.
	The feature string is of the format:

		2-eta_chieff_s1

	This represents a second order polynomial in the variables eta, chieff and s1

	"""
	#theta = np.atleast_2d(theta)
	feats_to_add = []
	features='2-mc_eta_logq_chieff'

	if not isinstance(features, list): features = [features]

	for feat_str in features:

		if not feat_str: continue

		if isinstance(feat_str, str):
			order, features_ = feat_str.split('-')
			order = int(order)
			features_ = features_.split('_')
		else:
			raise ValueError("Each input feature must be a string")

		if not (features_ and order>1): continue

		features_.sort()
		feat_list = []
		for i in range(1,order):
			feat_list.extend(combinations_with_replacement(features_, i+1))

		feat_vals = {}
		for f in features_:
			if f == 'eta':
				val = theta[:,0] / (1+theta[:,0])**2
			elif f == 'chieff':
				#chieff = (m1*s1+m2*s2)/(m1+m2) = (q*s1+s2)/(1+q)
				val = (theta[:,0]*theta[:,1] + theta[:,2]) / (1 + theta[:,0])
			elif f == 'q':
				val = theta[:,0]
			elif f == 'logq':
				val = jnp.log(theta[:,0])
			elif f == 's1':
				val = theta[:,1]
			elif f == 's2':
				val = theta[:,2]
			elif f == 'mc':
				val = jnp.power(theta[:,0] / (1+theta[:,0])**2, 3/5)
			else:
				raise ValueError("Feature '{}' not recognized: please consider submitting a patch to add support for your favoutite feature.".format(f))
			if f not in ['q', 's1', 's2']: feats_to_add.append(val[:,None])
			feat_vals[f] = val

		for feats in feat_list:
			val = 1
			for f in feats:
				val *= feat_vals[f]
			feats_to_add.append(val[:,None])

	return jnp.concatenate([theta, *feats_to_add], axis = 1)

def augment_features_ph_2345(theta):
	"""
	Given a list of features string, it computes all the polynomial features.
	The feature string is of the format:

		2-eta_chieff_s1

	This represents a second order polynomial in the variables eta, chieff and s1

	"""
	#theta = np.atleast_2d(theta)
	feats_to_add = []
	features='1-mc_eta_logq_chieff'

	if not isinstance(features, list): features = [features]

	for feat_str in features:

		if not feat_str: continue

		if isinstance(feat_str, str):
			order, features_ = feat_str.split('-')
			order = int(order)
			features_ = features_.split('_')
		else:
			raise ValueError("Each input feature must be a string")

		if not (features_ and order>1): continue

		features_.sort()
		feat_list = []
		for i in range(1,order):
			feat_list.extend(combinations_with_replacement(features_, i+1))

		feat_vals = {}
		for f in features_:
			if f == 'eta':
				val = theta[:,0] / (1+theta[:,0])**2
			elif f == 'chieff':
				#chieff = (m1*s1+m2*s2)/(m1+m2) = (q*s1+s2)/(1+q)
				val = (theta[:,0]*theta[:,1] + theta[:,2]) / (1 + theta[:,0])
			elif f == 'q':
				val = theta[:,0]
			elif f == 'logq':
				val = jnp.log(theta[:,0])
			elif f == 's1':
				val = theta[:,1]
			elif f == 's2':
				val = theta[:,2]
			elif f == 'mc':
				val = jnp.power(theta[:,0] / (1+theta[:,0])**2, 3/5)
			else:
				raise ValueError("Feature '{}' not recognized: please consider submitting a patch to add support for your favoutite feature.".format(f))
			if f not in ['q', 's1', 's2']: feats_to_add.append(val[:,None])
			feat_vals[f] = val

		for feats in feat_list:
			val = 1
			for f in feats:
				val *= feat_vals[f]
			feats_to_add.append(val[:,None])

	return jnp.concatenate([theta, *feats_to_add], axis = 1)

def intermediate_layer_fn(x, w, b):
        z = jnp.dot(x, w) + b
        a_out = jnn.sigmoid(z)
        return a_out

def final_layer_fn(x,w,b):
      z= jnp.dot(x, w) + b
      return z

def ampNN_function(theta,w,b):
  theta_amp=augment_features_amp(theta)
  a1=intermediate_layer_fn(theta_amp,w[0],b[0])
  a2=final_layer_fn(a1,w[1],b[1])
  return a2

def phi01_function(theta,w,b):
  theta_ph_01=augment_features_ph_01(theta)
  a1=intermediate_layer_fn(theta_ph_01,w[0],b[0])
  a2=intermediate_layer_fn(a1,w[1],b[1])
  a3=final_layer_fn(a2,w[2],b[2])
  return a3

def phi_res_01_function(theta,w,b):
  theta_res_ph_01=augment_features_ph_res_01(theta)
  a1=intermediate_layer_fn(theta_res_ph_01,w[0],b[0])
  a2=intermediate_layer_fn(a1,w[1],b[1])
  a3=intermediate_layer_fn(a2,w[2],b[2])
  a4=intermediate_layer_fn(a3,w[3],b[3])
  a5=intermediate_layer_fn(a4,w[4],b[4])
  a6=final_layer_fn(a5,w[5],b[5])
  return a6

def phi_res_01_function_final(theta,w,b,residual_coefficients_01):
  res1=phi_res_01_function(theta,w,b)
  res2=res1*residual_coefficients_01
  return res2

def phi_2345_function(theta,w,b):
  theta_ph_2345=augment_features_ph_2345(theta) # Changed from augment_features_ph_res_01
  a1=intermediate_layer_fn(theta_ph_2345,w[0],b[0])
  a2=final_layer_fn(a1,w[1],b[1])
  return a2

def model_output_amp(theta,w,b):
      return ampNN_function(theta,w,b)

def model_output_ph(theta,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01):
      coef_pre_01=phi01_function(theta,w01,b01)
      coef_res_01=phi_res_01_function_final(theta,wres01,bres01,residual_coefficients_01)
      coef_post_01=coef_pre_01+coef_res_01
      coef_ph_2345=phi_2345_function(theta,w2345,b2345)
      ph_coef=jnp.concatenate((coef_post_01,coef_ph_2345),axis=1)
      return ph_coef

def model_output_ph_2(theta,w01,b01,w2345,b2345):
      coef_pre_01=phi01_function(theta,w01,b01)
      coef_post_01=coef_pre_01
      coef_ph_2345=phi_2345_function(theta,w2345,b2345)
      ph_coef=jnp.concatenate((coef_post_01,coef_ph_2345),axis=1)
      return ph_coef

def get_raw_mode(theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01):
		"""
		This function takes as input theta=[q,spin1z,spin2z].
		With the theta=[q,spin1z,spin2z] it augment the features to the 37 necessary inputs, and only a portion of those inputs shall be used by the model_out_amp and model_output_ph
		"""
		rec_PCA_amp = model_output_amp(theta,wa,ba) #(N,K)
		rec_PCA_ph = model_output_ph(theta,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01) #(N,K)
		rec_amp = amp_PCA.reconstruct_data_jnp(rec_PCA_amp) #(N,D)
		rec_ph = ph_PCA.reconstruct_data_jnp(rec_PCA_ph) #(N,D)
		return rec_amp, rec_ph

def get_raw_mode_2(theta,wa,ba,w01,b01,w2345,b2345):
		"""
		This function takes as input theta=[q,spin1z,spin2z].
		With the theta=[q,spin1z,spin2z] it augment the features to the 37 necessary inputs, and only a portion of those inputs shall be used by the model_out_amp and model_output_ph
		"""
		rec_PCA_amp = model_output_amp(theta,wa,ba) #(N,K)
		rec_PCA_ph = model_output_ph_2(theta,w01,b01,w2345,b2345) #(N,K)
		rec_amp = amp_PCA.reconstruct_data_jnp(rec_PCA_amp) #(N,D)
		rec_ph = ph_PCA.reconstruct_data_jnp(rec_PCA_ph) #(N,D)
		return rec_amp, rec_ph

def __get_mode(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2)):
      """
      It generates the mode (2,2) by means of the function __get_mode,
      the input should be the 4D theta array defined as
      theta=[theta_1, theta_2, theta_3, theta_4]=[m1,m2,spin1z,spin2z]
      This theta is processed in the following way:
      The two masses [m1, m2]= [theta_1, theta_2] will be summed up to produce m_tot_us = m1+m2
      the mass-ratio q is extracted by taking the ration between m1 and m2.
      The final used theta input array is the array [theta_input_1, theta_input_2, theta_input_3]= [q, spin1z,spin2z] which is handed over to the function get_raw_mode, which demands a theta_final=[q,spin1z,spin2z] as input.

      THe output are the pure components h_c and h_p of the (2,2) mode, namely in terms of the amplitude and the phase amp and ph
      """
      q = jnp.divide(theta[:,0],theta[:,1]) #theta[:,0]/theta[:,1] #mass ratio (general) (N,)
      m_tot_us = theta[:,0] + theta[:,1]      #total mass in solar masses for the user
      theta_std = jnp.column_stack((q,theta[:,2],theta[:,3])) #(N,3)

      # Use masking and select to handle conditional swapping
      mask = theta_std[:,0] < 1.0
        # Create swapped versions of the relevant columns
      swapped_q = jnp.power(theta_std[:, 0], -1)
      swapped_theta2 = theta_std[:, 2]
      swapped_theta3 = theta_std[:, 1]

        # Select between original and swapped values based on the mask
      theta_std_swapped = jnp.column_stack([
          jax.lax.select(mask, swapped_q, theta_std[:, 0]),
          jax.lax.select(mask, swapped_theta2, theta_std[:, 1]),
          jax.lax.select(mask, swapped_theta3, theta_std[:, 2])
      ])

      # Ensure theta_final has the correct dimensions for get_raw_mode
      # Based on previous error, theta_final should be (N, 3) to match the expected input of model_output_ph
      # However, augment_features_jnp takes (N, 3) and returns (N, 37), which seems to be the intended input
      theta_final = theta_std_swapped
      # Use jax.vmap for vectorized interpolation

      def interp_fn(amp_i, ph_i, m_tot_us_i):
          interp_grid = jnp.divide(t_grid, m_tot_us_i)
          new_amp_i = jnp.interp(interp_grid, times_saved, amp_i, left=0, right=0)
          new_ph_i = jnp.interp(interp_grid, times_saved, ph_i)
          return new_amp_i, new_ph_i


      amp, ph =  get_raw_mode(theta_final,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01) #raw WF (N, N_grid)

      new_amp, new_ph = jax.vmap(interp_fn)(amp, ph, m_tot_us)

      # Recalculate nu based on the potentially swapped theta_std_swapped
      nu = theta_std_swapped[:,0]/(1 + theta_std_swapped[:,0])**2
      phi_diff = {(2,2):0, (2,1):jnp.pi/2, (3,3): -jnp.pi/2, (4,4):jnp.pi, (5,5): jnp.pi/2}
      # Ensure nu is broadcastable for multiplication
      amp = new_amp * nu[:, jnp.newaxis]
      phase = (new_ph.T - new_ph[:,0] + phi_diff[mode]).T #phase is zero at the beginning of the WF
      return amp, phase

def __get_mode_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2)):
      """
      It generates the mode (2,2) by means of the function __get_mode,
      the input should be the 4D theta array defined as
      theta=[theta_1, theta_2, theta_3, theta_4]=[m1,m2,spin1z,spin2z]
      This theta is processed in the following way:
      The two masses [m1, m2]= [theta_1, theta_2] will be summed up to produce m_tot_us = m1+m2
      the mass-ratio q is extracted by taking the ration between m1 and m2.
      The final used theta input array is the array [theta_input_1, theta_input_2, theta_input_3]= [q, spin1z,spin2z] which is handed over to the function get_raw_mode, which demands a theta_final=[q,spin1z,spin2z] as input.

      THe output are the pure components h_c and h_p of the (2,2) mode, namely in terms of the amplitude and the phase amp and ph
      """
      q = jnp.divide(theta[:,0],theta[:,1]) #theta[:,0]/theta[:,1] #mass ratio (general) (N,)
      m_tot_us = theta[:,0] + theta[:,1]      #total mass in solar masses for the user
      theta_std = jnp.column_stack((q,theta[:,2],theta[:,3])) #(N,3)

      # Use masking and select to handle conditional swapping
      mask = theta_std[:,0] < 1.0
        # Create swapped versions of the relevant columns
      swapped_q = jnp.power(theta_std[:, 0], -1)
      swapped_theta2 = theta_std[:, 2]
      swapped_theta3 = theta_std[:, 1]

        # Select between original and swapped values based on the mask
      theta_std_swapped = jnp.column_stack([
          jax.lax.select(mask, swapped_q, theta_std[:, 0]),
          jax.lax.select(mask, swapped_theta2, theta_std[:, 1]),
          jax.lax.select(mask, swapped_theta3, theta_std[:, 2])
      ])

      # Ensure theta_final has the correct dimensions for get_raw_mode
      # Based on previous error, theta_final should be (N, 3) to match the expected input of model_output_ph
      # However, augment_features_jnp takes (N, 3) and returns (N, 37), which seems to be the intended input
      theta_final = theta_std_swapped
      # Use jax.vmap for vectorized interpolation

      def interp_fn(amp_i, ph_i, m_tot_us_i):
          interp_grid = jnp.divide(t_grid, m_tot_us_i)
          new_amp_i = jnp.interp(interp_grid, times_saved, amp_i, left=0, right=0)
          new_ph_i = jnp.interp(interp_grid, times_saved, ph_i)
          return new_amp_i, new_ph_i


      amp, ph =  get_raw_mode_2(theta_final,wa,ba,w01,b01,w2345,b2345) #raw WF (N, N_grid)

      new_amp, new_ph = jax.vmap(interp_fn)(amp, ph, m_tot_us)

      # Recalculate nu based on the potentially swapped theta_std_swapped
      nu = theta_std_swapped[:,0]/(1 + theta_std_swapped[:,0])**2
      phi_diff = {(2,2):0, (2,1):jnp.pi/2, (3,3): -jnp.pi/2, (4,4):jnp.pi, (5,5): jnp.pi/2}
      # Ensure nu is broadcastable for multiplication
      amp = new_amp * nu[:, jnp.newaxis]
      phase = (new_ph.T - new_ph[:,0] + phi_diff[mode]).T #phase is zero at the beginning of the WF
      return amp, phase

def get_mode(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2)):
		"""
		It generates the mode (2,2) by means of the function __get_mode,
		the input should be the 4D theta array defined as
		theta=[theta_1, theta_2, theta_3, theta_4]=[m1,m2,spin1z,spin2z]
		THe output are the pure components h_c and h_p of the (2,2) mode, namely in terms of the amplitude and the phase amp and phase
		"""
		amp,phase = __get_mode(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2))
		return amp, phase #(N,D)

def get_mode_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2)):
		"""
		It generates the mode (2,2) by means of the function __get_mode,
		the input should be the 4D theta array defined as
		theta=[theta_1, theta_2, theta_3, theta_4]=[m1,m2,spin1z,spin2z]
		THe output are the pure components h_c and h_p of the (2,2) mode, namely in terms of the amplitude and the phase amp and phase
		"""
		amp,phase = __get_mode_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2))
		return amp, phase #(N,D)

def __get_WF_jnp(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2)):
                """
                Generates the waves in time domain, building it as a sum of modes weighted by spherical harmonics. Called by get_WF.
                Accepts only input features as [q,s1,s2] or [m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0].

                Input:
                        theta: :class:`~numpy:numpy.ndarray`
                                shape (D,)/(N,D) - source parameters to make prediction at (D=7)
                        t_grid: :class:`~numpy:numpy.ndarray`
                                shape (D',) - a grid in (reduced) time to evaluate the wave at (uses np.interp)
                        modes: list
                                list of modes employed for building the WF (if None, every mode available is employed)

                         Here you should give a 7 dimmensional theta where
                            theta= [m1,m2, spin1_z, spin2_z, D_l, inclination, phi_0]

                          This 7 dimmensional input for theta will be processed in the following way.
                          The two masses [m1, m2]= [theta_1, theta_2] will be summed up to produce m_tot_us = m1+m2
                          and the distance dist=theta_4 will be used to produce the value for the distance "dist".
                          Those values will give us the amplitude pre factor "amp_prefactor".
                          Finally, only the first four components of theta = [theta_1, theta_2, theta_3, theta_4] = [m1,m2,spin1z,spin2z] will be used to produce the mode for amp_22, ph_22 by means
                          of the previously defined function get_mode
                Ouput:
                        h_plus, h_cross: :class:`~numpy:numpy.ndarray`
                                shape (D,)/(N,D) - desidered polarizations (if it applies)
                """
                #computing amplitude prefactor
                prefactor = 4.7864188273360336e-20 # G/c^2*(M_sun/Mpc)
                m_tot_us = theta[:,0] + theta[:,1]    #total mass in solar masses for the user  (N,)
                dist= theta[:,4]
                amp_prefactor = prefactor * m_tot_us / dist # G/c^2 (M / d_L)

                #theta input for the get_mode function
                theta_input=theta[:,:4]
                #generating waves and returning to user

                amp_22, ph_22 = get_mode(t_grid, theta_input,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2))
                # Correct broadcasting for amp_prefactor
                amp_22 = jnp.sqrt(5/(4.*jnp.pi)) * amp_22 * amp_prefactor[:, jnp.newaxis] #G/c^2*(M_sun/Mpc) nu *(M/M_sun)/(d_L/Mpc)
                #setting spherical harmonics by hand
                c_i = jnp.cos(theta[:,5]) #(N,)
                h_p = jnp.multiply(jnp.multiply(amp_22.T,jnp.cos(ph_22.T+2.*theta[:,6])), 0.5*(1+jnp.square(c_i)) ).T
                h_c = jnp.multiply(jnp.multiply(amp_22.T,jnp.sin(ph_22.T+2.*theta[:,6])), c_i ).T
                return h_p, h_c

def __get_WF_jnp_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2)):
                """
                Generates the waves in time domain, building it as a sum of modes weighted by spherical harmonics. Called by get_WF.
                Accepts only input features as [q,s1,s2] or [m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0].

                Input:
                        theta: :class:`~numpy:numpy.ndarray`
                                shape (D,)/(N,D) - source parameters to make prediction at (D=7)
                        t_grid: :class:`~numpy:numpy.ndarray`
                                shape (D',) - a grid in (reduced) time to evaluate the wave at (uses np.interp)
                        modes: list
                                list of modes employed for building the WF (if None, every mode available is employed)

                         Here you should give a 7 dimmensional theta where
                            theta= [m1,m2, spin1_z, spin2_z, D_l, inclination, phi_0]

                          This 7 dimmensional input for theta will be processed in the following way.
                          The two masses [m1, m2]= [theta_1, theta_2] will be summed up to produce m_tot_us = m1+m2
                          and the distance dist=theta_4 will be used to produce the value for the distance "dist".
                          Those values will give us the amplitude pre factor "amp_prefactor".
                          Finally, only the first four components of theta = [theta_1, theta_2, theta_3, theta_4] = [m1,m2,spin1z,spin2z] will be used to produce the mode for amp_22, ph_22 by means
                          of the previously defined function get_mode
                Ouput:
                        h_plus, h_cross: :class:`~numpy:numpy.ndarray`
                                shape (D,)/(N,D) - desidered polarizations (if it applies)
                """
                #computing amplitude prefactor
                prefactor = 4.7864188273360336e-20 # G/c^2*(M_sun/Mpc)
                m_tot_us = theta[:,0] + theta[:,1]    #total mass in solar masses for the user  (N,)
                dist= theta[:,4]
                amp_prefactor = prefactor * m_tot_us / dist # G/c^2 (M / d_L)

                #theta input for the get_mode function
                theta_input=theta[:,:4]
                #generating waves and returning to user

                amp_22, ph_22 = get_mode_2(t_grid, theta_input,wa,ba,w01,b01,w2345,b2345,mode=(2,2))
                # Correct broadcasting for amp_prefactor
                amp_22 = jnp.sqrt(5/(4.*jnp.pi)) * amp_22 * amp_prefactor[:, jnp.newaxis] #G/c^2*(M_sun/Mpc) nu *(M/M_sun)/(d_L/Mpc)
                #setting spherical harmonics by hand
                c_i = jnp.cos(theta[:,5]) #(N,)
                h_p = jnp.multiply(jnp.multiply(amp_22.T,jnp.cos(ph_22.T+2.*theta[:,6])), 0.5*(1+jnp.square(c_i)) ).T
                h_c = jnp.multiply(jnp.multiply(amp_22.T,jnp.sin(ph_22.T+2.*theta[:,6])), c_i ).T
                return h_p, h_c

def get_WF_jnp(t_grid, theta, wa, ba, w01, b01, wres01, bres01, w2345, b2345,residual_coefficients_01, mode=(2,2)):
		"""
		Generates a WF according to the model. It makes all the required preprocessing to include wave dependance on the full 14 parameters space of the GW forms. It outputs the plus cross polarization of the WF.
		The WF is shifted such that the peak of the 22 mode is placed at t=0. If the reference phase is 0, the phase of the 22 mode is 0 at the beginning of the time grid.
		It accepts data in the following layout of D features:

			D = 7	[m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0]

		In the D = 3 layout, the total mass is set to 20 M_sun by default.
		Warning: last layout (D=14) is made only for compatibility with lalsuite software. The implemented variables are those in D=7 layout; the other are dummy variables and will not be considered.
		Unit of measures:

			[mass] = M_sun

			[D_L] = Mpc

			[spin] = adimensional

		Input:
			theta: :class:`~numpy:numpy.ndarray`
				shape (D,)/(N,D) - source parameters to make prediction at
			t_grid: :class:`~numpy:numpy.ndarray`
				shape (D',) - a grid in (reduced) time to evaluate the wave at (uses np.interp)
			modes: list
				list of modes employed for building the WF (if None, every mode available is employed
      Here you should give a 7 dimmensional theta where
      theta= [m1,m2, spin1_z, spin2_z, D_l, inclination, phi_0]

		Ouput:
			h_plus, h_cross (D,)/(N,D)		desidered polarizations (if it applies)
		"""
		#TODO: this function eventually should take f_ref. If f_ref is not None, the spin will be evolved up to our merger frequency
		D= theta.shape[1] #number of features given
		indices = [i for i in range(D)]
		indices_new_theta = indices
		#generating waves and returning to user
		h_plus, h_cross = __get_WF_jnp(t_grid, theta,wa,ba,w01,b01,wres01,bres01,w2345,b2345,residual_coefficients_01,mode=(2,2)) #(N,D)
		return h_plus, h_cross #(N,D)

def get_WF_jnp_2(t_grid, theta, wa, ba, w01, b01, w2345, b2345, mode=(2,2)):
		"""
		Generates a WF according to the model. It makes all the required preprocessing to include wave dependance on the full 14 parameters space of the GW forms. It outputs the plus cross polarization of the WF.
		The WF is shifted such that the peak of the 22 mode is placed at t=0. If the reference phase is 0, the phase of the 22 mode is 0 at the beginning of the time grid.
		It accepts data in the following layout of D features:

			D = 7	[m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0]

		In the D = 3 layout, the total mass is set to 20 M_sun by default.
		Warning: last layout (D=14) is made only for compatibility with lalsuite software. The implemented variables are those in D=7 layout; the other are dummy variables and will not be considered.
		Unit of measures:

			[mass] = M_sun

			[D_L] = Mpc

			[spin] = adimensional

		Input:
			theta: :class:`~numpy:numpy.ndarray`
				shape (D,)/(N,D) - source parameters to make prediction at
			t_grid: :class:`~numpy:numpy.ndarray`
				shape (D',) - a grid in (reduced) time to evaluate the wave at (uses np.interp)
			modes: list
				list of modes employed for building the WF (if None, every mode available is employed
      Here you should give a 7 dimmensional theta where
      theta= [m1,m2, spin1_z, spin2_z, D_l, inclination, phi_0]

		Ouput:
			h_plus, h_cross (D,)/(N,D)		desidered polarizations (if it applies)
		"""
		#TODO: this function eventually should take f_ref. If f_ref is not None, the spin will be evolved up to our merger frequency
		#generating waves and returning to user
		h_plus, h_cross = __get_WF_jnp_2(t_grid, theta,wa,ba,w01,b01,w2345,b2345,mode=(2,2)) #(N,D)
		return h_plus, h_cross #(N,D)

"""## IMPORTING THE MODEL"""

loading_NN=loading_NN_weights_bias()

w_AMP=loading_NN.w_amp
b_AMP=loading_NN.b_amp

w_PH_01=loading_NN.w_ph_01
b_PH_01=loading_NN.b_ph_01

w_PH_res_01=loading_NN.w_res_ph_01
b_PH_res_01=loading_NN.b_res_ph_01

w_PH_2345=loading_NN.w_ph_2345
b_PH_2345=loading_NN.b_ph_2345

residual_coefficients_01=loading_NN.residual_coefficients_01

folder=loading_NN.importing_folder

folder_path = Path(folder)
amp_PCA = PCA_model()
amp_PCA.load_model(*glob.glob(str(folder_path/"amp_PCA_model*")))
ph_PCA = PCA_model()
ph_PCA.load_model(*glob.glob(str(folder_path/"ph_PCA_model*")))
times_saved = np.loadtxt(*glob.glob(str(folder_path/"times*")))

t_min_red=times_saved[0]
t_max_red=times_saved[-1]

"""# TD and FD WRAPPER FUNCTION

## DEFINING THE FUNCTION
"""

def GET_WF_TD(t_grid,theta):
  hp,hc=get_WF_jnp(t_grid, theta, w_AMP,b_AMP,w_PH_01,b_PH_01,w_PH_res_01,b_PH_res_01,w_PH_2345,b_PH_2345,residual_coefficients_01,mode=(2,2))
  return hp,hc

"""## DEFINING THE FOURIER TRANSFORM"""


def compute_time_grid(theta, sample_rate):
    m1 = theta[:, 0]
    m2 = theta[:, 1]
    m_tot = m1 + m2

    t_min_phys = m_tot * t_min_red
    t_max_phys = m_tot * t_max_red
    t_interval = t_max_phys - t_min_phys

    t_interval_max_ind = jnp.argmax(t_interval)

    t_min_f = t_min_phys[t_interval_max_ind]
    t_max_f = t_max_phys[t_interval_max_ind]

    delta_t = 1.0 / sample_rate
    number_points = jnp.array((((t_max_f - t_min_f) * sample_rate)),int)  # safe here

    t_grid_final = t_min_f + jnp.arange(number_points) * delta_t
    return t_grid_final

def to_frequencyseries_slice_padding_jax_01_3(theta, sample_rate, t_grid):
    Hp, Hc = GET_WF_TD(t_grid, theta)
    number_points = t_grid.shape[0]
    flen = number_points // 2 + 1
    delta_t=1.0 / sample_rate


    freq_grid = jnp.fft.rfftfreq(number_points, delta_t)

    hp_f = jnp.fft.rfft(Hp, axis=-1) * delta_t
    hc_f = jnp.fft.rfft(Hc, axis=-1) * delta_t

    hp_f_final = hp_f[:, :flen]
    hc_f_final = hc_f[:, :flen]
    freq_grid_final = freq_grid[:flen]

    return Hp, Hc, hp_f_final, hc_f_final, freq_grid_final

def interpolation(f_new,f_old,hp):
  return jnp.interp(f_new,f_old,hp)

def interp_waveform_fd_mlgw_jax(f_grid_final,f_grid_old,h):
  # Change in_axes to (None, None, 0) to map only over the waveform batch
  H=jax.vmap(interpolation,in_axes=(None,None,0))(f_grid_final,f_grid_old,h)
  return H

def GET_WF_FD_f(theta,f_grid,sample_rate,t_grid):
  df=f_grid[1]-f_grid[0]	
  Hp, Hc, hp_f_final, hc_f_final, freq_grid_final=to_frequencyseries_slice_padding_jax_01_3(theta, sample_rate, t_grid)
  HP=interp_waveform_fd_mlgw_jax(f_grid,freq_grid_final,hp_f_final)
  HC=interp_waveform_fd_mlgw_jax(f_grid,freq_grid_final,hc_f_final)
  return HP,HC











"""# TD and FD WRAPPER FUNCTION

## TO BE REMOVED SOON
"""

def to_frequencyseries_slice_padding(theta, sample_rate, delta_f):
    """
    Returns the rFFT of time-domain waveforms, padded to common length,
    ensuring a consistent frequency grid for all.

    Parameters
    ----------
    theta : array (N, d)
        Parameter vectors for each waveform
    sample_rate : float
        Sampling frequency in Hz
    delta_f : float
        Desired frequency resolution in Hz

    Returns
    -------
    hpf, hcf : arrays (N, flen)
        Real-valued FFTs of plus/cross polarizations
    """
    delta_t = 1.0 / sample_rate
    tlen = int(1.0 / delta_f / delta_t + 0.5)
    duration_time = tlen * delta_t
    t_grid = jnp.arange(-duration_time + 0.1, 0.1, delta_t)
    tlenght = len(t_grid)
    flen = int(tlenght / 2 + 1)  # Output length of rfft

    # Generate full waveforms
    hp, hc = GET_WF_TD(t_grid, theta)  # Shape: (N, tlenght)

    # Define reduction bounds
    t_red_lim_0 = t_min_red  # example values, adjust as needed
    t_red_lim_1 = t_max_red

    m1 = theta[:, 0]
    m2 = theta[:, 1]
    m_tot = m1 + m2

    t_min = m_tot * t_red_lim_0
    t_max = m_tot * t_red_lim_1

    start_index = jax.vmap(lambda t: jnp.searchsorted(t_grid, t))(t_min)
    end_index   = jax.vmap(lambda t: jnp.searchsorted(t_grid, t))(t_max)

    # Determine the length of the sliced waveform for each element and the maximum length
    sliced_lengths = end_index - start_index
    max_sliced_length = jnp.max(sliced_lengths)
    ind_max=jnp.argmax(sliced_lengths)

    def slice_and_pad(h_i, start_i,end_i):
      """Slice signal using lax.dynamic_slice and pad to match tlenght."""
      #length = end_i - start_i
      # dynamic_slice needs a fixed shape to slice into, so we must slice a portion of fixed size.
      # We pad AFTER slicing.
      slice_i = jax.lax.dynamic_slice(h_i, (start_i,), (max_sliced_length,))
      #pad_left = start_i
      #pad_right = tlenght - end_i
      #padded = jnp.pad(slice_i, (pad_left, pad_right), constant_values=0)
      return slice_i

    # Pad all waveforms to uniform length for consistent FFT
    hp_sliced = jax.vmap(slice_and_pad)(hp, start_index,end_index)
    hc_sliced = jax.vmap(slice_and_pad)(hc, start_index,end_index)

    # Adjust flen based on the slicing length
    flen_slicing = int(max_sliced_length / 2 + 1)

    # Compute FFT over uniform-length signals → consistent frequency grid
    hpf = jnp.fft.rfft(hp_sliced, axis=-1)*delta_t
    hcf = jnp.fft.rfft(hc_sliced, axis=-1)*delta_t
    freq_grid=jnp.fft.rfftfreq(max_sliced_length, delta_t)

    freq=freq_grid[:flen_slicing]
    hp_f=hpf[:,:flen_slicing]
    hc_f=hcf[:,:flen_slicing]

    return freq,hp_f, hc_f






def to_frequencyseries_slice_padding_jax_01(theta, sample_rate, delta_f):
    """
    JAX-compatible version of to_frequencyseries_slice_padding_5.
    Returns the rFFT of time-domain waveforms, padded to common length,
    ensuring a consistent frequency grid for all.

    Parameters
    ----------
    theta : array (N, d)
        Parameter vectors for each waveform
    sample_rate : float
        Sampling frequency in Hz
    delta_f : float
        Desired frequency resolution in Hz
    t_min_red : float
        Minimum reduced time for slicing.
    t_max_red : float
        Maximum reduced time for slicing.

    Returns
    -------
    hpf, hcf : arrays (N, flen)
        Real-valued FFTs of plus/cross polarizations
    """
    delta_t = 1.0 / sample_rate

    m1 = theta[:, 0]
    m2 = theta[:, 1]
    m_tot = m1 + m2

    t_min_phys = m_tot * t_min_red
    t_max_phys = m_tot * t_max_red

    t_interval=t_max_phys-t_min_phys
    t_interval_max=jnp.max(t_interval)
    t_interval_max_ind=jnp.argmax(t_interval)
    

    t_min_f=t_min_phys[t_interval_max_ind]
    t_max_f=t_max_phys[t_interval_max_ind]


    number_points = jnp.array((((t_max_f - t_min_f) * sample_rate)),int)
    t_grid_final = t_min_f + jnp.arange(number_points) * delta_t

    Hp,Hc=GET_WF_TD(t_grid_final,theta)

    # Determine the frequency grid based on the maximum waveform length and delta_t
    freq_grid = jnp.fft.rfftfreq(number_points, delta_t)
    flen = jnp.array((number_points / 2 + 1),int)
    freq_grid_final = freq_grid[:flen]

    # Compute FFT over uniform-length padded signals
    hp_f = jnp.fft.rfft(Hp, axis=-1) * delta_t
    hc_f = jnp.fft.rfft(Hc, axis=-1) * delta_t

    hp_f_final = hp_f[:, :flen]
    hc_f_final = hc_f[:, :flen]

    # Note: The time grids in T_grid_list are not padded.
    # We return the final frequency grid, padded waveforms, and frequency-domain waveforms
    return Hp, Hc, t_grid_final, hp_f_final, hc_f_final, freq_grid_final




def GET_WF_FD(theta,f_grid,sample_rate):
  df=f_grid[1]-f_grid[0]
  Hp, Hc, t_grid_final, hp_f_final, hc_f_final, freq_grid_final=to_frequencyseries_slice_padding_jax_01(theta, sample_rate, df)
  HP=interp_waveform_fd_mlgw_jax(f_grid,freq_grid_final,hp_f_final)
  HC=interp_waveform_fd_mlgw_jax(f_grid,freq_grid_final,hc_f_final)
  return HP,HC
